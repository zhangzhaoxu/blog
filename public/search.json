[{"title":"网站全球加速","url":"/2019/12/03/网站全球加速/","content":"\n\n### 遇到的问题\n\n国内部署的网站在国外访问慢甚至不能打开\n\n### 解决方案\n\n借助腾讯提供的基于`BGP AnyCast`全球加速方案以及动态配置静态资源，实现应用在全球的可访问。\n\n先上图\n\n<img src=\"http://images.tuyacn.com/smart/connect-scheme/1580285192aa5d42d3734.png\" width=\"600\" height=\"auto\">\n\n**大致流程如下（以test.huaishuo.com为例）**\n\n- 经过阿里智能DNS解析，国外用户访问`test.huaishuo.com` `CNAME` 到一个 `CDN`域名\n- `CDN` 回源到 `test-acc.huaishuo.com`\n- `test-acc.huaishuo.com` 指向腾讯`AnyCast`加速ip\n- 经过腾讯专用通道加速到国内SLB负载均衡设备\n- SLB分流到不同的nginx\n- nginx添加国外加速访问专属头部`x-ty-acc`\n- 经过`k8s ingress`到最终的容器`pod`\n- 如果是html请求，则具体应用根据`x-ty-acc`更改静态资源前缀到国外CDN（这要求发布时静态资源要同步国外）\n- 返回具体数据\n\n### 针对流程中几个点的解释\n\n**1. 阿里智能DNS解析**\n\n`test.huaishuo.com`由阿里DNS负责解析，用户在访问域名的时候，会携带具体用户的访问ip到阿里DNS，阿里DNS作出判断分别解析成`A记录`或`CNAME`记录等。在这里我们配置的是国外访问`CNAME`到一个CDN的地址。\n\n\n**2.BGP AnyCast加速是什么**\n\n先上链接\n[https://www.cnblogs.com/zafu/p/9168617.html](https://www.cnblogs.com/zafu/p/9168617.html)\n\n`Anycast`是指`IPV6协议`中一个`发送方` 同 `最近的一组接收方` 之间的通信。其利用多个`as`号码在不同地区广播同一个`ip`段。\n\n最简单的理解就是，`不同的`的服务器用了`相同的`ip地址，然后用户访问这个ip的时候，利用`BGP`的寻路原则，选择一条最优路径，从而优化了访问速度\n\n*为何可以使用相同的ip?*\n\n传统意义上的ip是唯一的，ip地址重复会报ip地址冲突，这里利用了`as号`，它就像是一个个国家的编号，不同国家其中可以拥有相同的一个ip。\n\n举例说明：\n\n<img src=\"https://images.tuyacn.com/smart/connect-scheme/1576502058be69b7d0c3e.png\" width=\"400\" height=\"auto\">\n\n比如我们有三台服务器分别部署在北京上海和广州。传统意义上，我们想要做分流需要有一台负载均衡设备，全国的流量打到这台设备上，然后这台设备根据具体的用户及服务器状态进行分流。\n\n而现在，如果使用了`BGP AnyCast`方案，这三台服务器对互联网宣告同一ip，然后互联网路由表针对此ip就有三个不同的出口路由。当用户访问这个ip时，不再需要负载均衡设备，根据`BGP`寻路自动找到一条最优路径\n\n除了最基础的`负载均衡`，它还有例如`防DDOS攻击`等更多有点，这里不多做赘述。\n\n\n*具体到腾讯的全球加速*\n\n- 腾讯在全球多个地区部署同一ip的服务器\n- 用户访问此ip根据BGP寻最优路径访问\n- 经过腾讯专线加速到国内\n\n**3.test.huaishuo.com CNAME 到 CDN是为什么？是否多余**\n\n单纯的通过腾讯的AnyCast的加速已经能够实现全球加速的效果，直接把国外访问的`test.huaishuo.com`解析到腾讯的加速ip上已经可以实现\n\n具体原因如下：\n\n- 腾讯全球部署的节点依然不够多，而CDN的节点在全球确是非常多，加了CDN之后，加速了从`用户`到`最优IP`的这一步。\n- 我们的请求有很多种\n  - 有例如 `test.huaishuo.com` 动态的页面，以及其中的动态的接口， 这种每次都是最新的，可以利用CDN的`动态加速`，每次请求先到最近的CDN服务节点，然后再通过CDN优化过的线路，回源到源站\n  - 有例如 `smartapp.huaishuo.com/appId` 这种内容几乎不会更新的，这种我们可以利用CDN的`事件驱动`缓存，此路径实际上被CDN缓存，但当它需要被更新时，比如后台上传了新app链接，能够触发CDN更新。当然这种实际能不能配我也布吉岛\n- 省钱，加速流量贵啊\n\n**4.根据x-ty-acc头在项目中的作用**\n\n国外访问会在nginx层添加`x-ty-acc`头\n\n首先需要清楚的是我们的静态资源（js, css)有两套部署方式，一是阿里oss（之后可能会迁移到腾讯），二是AWS s3。这两种方式分别对应`static1.huaishuocn.com`, `static1.huaishuous.com`CDN前缀，后者在全球有很多节点，所以国外统一用`static1.huaishuous.com`。\n\n然后就是根据项目中是否收到`x-ty-acc`配置静态资源CDN前缀\n\n\n以上，如有错误，请联系@张照煦\n\n\n","tags":["web运维","加速"]},{"title":"H5唤醒app方式汇总","url":"/2019/04/03/H5唤醒app方式汇总/","content":"\n\n### H5唤醒App方式汇总\n\n最近在做扫码之后的h5页面唤醒App的功能，做下记录\n\n**1.唤醒方式列表**\n- URL Schemes\n- chrome intent\n- ios UniversalLink / android appLink\n\n**2.常见唤醒媒介**\n- iframe\n- a标签\n- window.location\n- URL Scheme\n\n**3.组成**\n```\n[scheme:][//authority][path][?query] 比如：tuyasmart://home?test=1\n```\n\n**4.是什么**\n\n*URL Schemes*可以理解为一种特殊的URL用来定位一个应用以及应用内的某个功能，类比网页链接便很容易理解\n*Schemes* 表示的是URL中的一个位置 - 最初始的位置，既`://`之前的字符，比如`https://www.apple.com`的*Schemes*就是`https`\n通过*URL Schemes*, 我们就可以像定位一个网页一样，定位一个应用甚至应用内的某个具体的功能。而定位是哪个应用的，就是*Schemes*部分。比如短信应用的Schemes就是： sms\n我们完全可以按照理解一个网页的URL来理解一个应用的URL\n|| 网页（苹果）| 应用（微信）| \n| 网站首页/打开应用 | https://www.apple.com | weixin:// |\n| 子页面/具体功能  | .../mac (Mac应用页) | weixin://dl/moments（朋友圈） |\n注意点 - 应用是否支持*URL Schemes*要看App开发者有没有写那部分的代码了 - *URL Schemes* 不唯一\n\n**5.使用**\n使用方式十分简单，就像我们打开一个链接一样，常见的有\n- location.href\n- iframe\n- a标签\n\n**6.使用中常见问题及解决方案**\n\n- 可能会被app禁掉，比如微信，qq等\n- ios9+ 禁止掉了iframe方式。\n- ios及部分安卓浏览器会提示用户是否打开App，并且ios在未安装对应App的时候，会提示“打不开网页，因为该网址无效”\nh5无法感知是否唤醒成功\n- 大部分浏览器需要用户手动触发链接，js自动触发无效\n\n针对被app禁止掉的情况，通常会判断是否微信等app环境，然后提示用户浏览器内打开 针对*ios9+ iframe* 被禁掉的情况，判断下ios版本 针对h5无法感知是否唤醒成功的解决办法是，`一段时间之后自动跳转下载页，或者是依赖setTimeout在浏览器进入后台后进程切换导致的时间延迟判断`。\n\n**7.Intent**\n\n安卓的原生谷歌浏览器从*chrome25*版本之后就不能通过*URL Schemes*唤醒安卓应用。要使用谷歌官方提供的*intent:*预发， 如果唤醒失败，则会跳转到谷歌的应用市场。语法与*URL Schemes*及其相似，相当于谷歌定制版的URL Schemes，也没用过，就不多说。\n\n\n**8.IOS Universal Link**\n简介 *Universal Link*是在iOS9引入的新功能，通过传统的HTTP链接就可以唤醒app，如果用户没有安装APP，则会跳转到该链接对应的页面，而且在唤醒app的时候没有弹框提示哦。可以说是解决了URL Schemes的大部分问题。\n\n*原理及流程*\n- App开发人员去配置中心配置Associated Domain配置一个支持https的域名，比如app-support.test.com\n- 然后 app-support.test.com/apple-app-site-association或者app-support.test.com/apple-app-site-association/.well-known/apple-app-site-association要返回app的teamId,bundleId,paths信息\n\n```js\nrouter.get('/apple-app-site-association, (req, res) => {\n  const data = {\n    applinks: {\n      apps: [],\n      details: [\n        {\n          appID: 'teamId.bundleId',\n          paths: ['*']\n        }\n      ]\n    }\n  };\n  res.set('Content-Type', 'text/html');\n  res.send(JSON.stringify(data));\n});\n```\n - 然后APP安装后首次打开，如果Associated Domain配置了的话，就会去请求app-support.test.com/apple-app-site-association。系统会根据返回的teamId,bundleId,paths知道当打开app-support.test.com下的哪些路径的时候唤醒对应的app，比如paths=*的话，就是打开app-support.test.com下的任意路径都会唤醒app\n \n - app那边会收到对应的路径，然后要根据path写逻辑跳转到对应的功能\n \n如何验证配置成功 - 在备忘录中输入配置好的链接，直接点开这个链接(https://app-support.test.com)，配置好的话会直接跳到app， 或者长按，弹出菜单中会提示在xxx中打开 - 在safari中\n\n*常见问题*\n\n- 微信等几个App还是给屏蔽了\n- 从9.3.X改版之后，通用链接不支持域内跳转了，跳转前后的两个domain必须是不同的，否则只会safari打开。比如知乎的网站地址是https://www.zhihu.com，而universal link的地址是oia.zhihu.com\n- 服务器上apple-app-site-association的更新不会让iOS本地的apple-app-site-association同步更新，即iOS只会在App第一次启动时请求一次，以后除非App更新或重新安装，否则不会在每次打开时请求apple-app-site-association。\n\n\n**9.Android App Links**\n安卓*App Link**的出现原因也是为了优化用户体验，在使用scheme唤醒时会弹出一个对话框提示用户是否打开，并且如果用户勾选了取消之后，可能之后就再也唤醒不了。\n安卓App Link的流程和*ios Universal link*的类似，iOS中需要配置的`app-support.test.com/apple-app-site-association`文件在安卓中叫做`app-support.test.com/.well-known/assetlinks.json`，只能放在.well-known下面","tags":["javascript","H5与app交互"]},{"title":"RX实现系列1","url":"/2019/03/18/Rx实现系列-1/","content":"\n### 本系列将一步步实现简化版的RxJS\n\n`RxJS`在我的观念里是一个有`流(streams)`式操作的观察者模型。\n我们将一步步通过简单的demo实现一个简化版的`RxJS`，没有Rx使用经验的人应该也看的懂\n\n#### 目标 - 实现如下功能\n\n```js\nconst compony$ = new Observable((observer) => {\n  let count = 0\n  const timer = setInterval(() => {\n    console.log('鲜奶公司发货')\n    observer.next(++count);\n  }, 1000);\n  return () => clearInterval(timer)\n})\n\ncompony$.pipe(\n  map(x => x + 1),\n  filter(x => x / 2 === 0)\n)\n\nconst xiaoming = (count) => console.log(`小明收到${count}瓶奶`)\n\nconst unsub = compony$.subscribe((xiaoming)\n\nsetTimeOut(() => unsub(), 30000);\n\n```\n\n先来解释下上面名词的含义, `compony$` 一个 `Observable - 可订阅（观察）对象`，负责在有顾客 `xiaoming - 订阅者（观察者)` 发出订阅动作之后，每隔一段时间发出一瓶奶，每天这个小明收到几瓶奶，也是经过一些处理的，也就是`pipe`中的一些操作`operator`。在30天取消订阅。\n\n本例引用自[Yard](http://www.yardwill.com/detail/%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84rxjs-demo%E6%9D%A5%E7%9C%8Brxjs%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81)\n\n#### 第一步\n*首先来实现一个`Observable`类，我们可以通过这个对象注册一个`可观测对象- Observable$`*\n\n```js\nclass Observable {\n  constructor(subscribe) {\n    if (subscribe) {\n      this._subscribe = subscribe\n    }\n  }\n}\n```\n\n实际使用中，注册的方式是传入一个函数。\n这个函数要具备的功能是：\n- 接受一个`observer`观察者，能给`observer`发出值\n- 返回一个取消订阅，也就是取消发出值的方法\n\n这就是那个函数：\n```js\n(observer) => {\n  let count = 0\n  const timer = setInterval(() => {\n    console.log('鲜奶公司发货')\n    observer.next(++count);\n  }, 1000);\n  return () => clearInterval(timer)\n}\n```\n\n#### 第二步\n*这个`Observable`中有一个`subscribe`方法，这个方法的作用是接受一个`observer`，进行格式化处理之后，将这个`observer`传给`Observable$`(即订阅动作)，`observer`开始接受`Observable$`发出的值*。\n\n*触发订阅动作的时候要返回注册函数提供的解绑方法，以供取消订阅使用*\n\n```js\nconst noon = () => {}\nconst toSubScriber = (observerOrNext, error, complete) => {\n  return {\n    next: observerOrNext ? observerOrNext : noon,\n    error: error ? error : noon,\n    complete: complete ? complete : noon,\n  }\n}\n\nclass Observable {\n  constructor(subscribe) {\n    if (subscribe) {\n      this._subscribe = subscribe\n    }\n  }\n\n  subscribe(observerOrNext, error, complete) {\n    const subscription = toSubScriber(observerOrNext, error, complete)\n    const unsub = this._subscribe(subscription)\n    return unsub\n  }\n}\n```\n\n到这里我们已经实现了一个很简单的观察者模型，让我们来试用下吧!\n\n```js\nconst compony$ = new Observable((observer) => {\n  let count = 0\n  const timer = setInterval(() => {\n    console.log('鲜奶公司发货')\n    observer.next(++count);\n  }, 1000);\n  return () => {\n    console.log('取消订阅');\n    clearInterval(timer)\n  }\n});\n\nconst xiaoming = (i) => console.log(`小明收到${i}瓶奶`)\n\nconst unsub = compony$.subscribe(xiaoming);\n\nsetTimeout(() => unsub(), 3000);\n```\n\n执行效果：\n\n\n### 第三步\n\n以上我们已经实现了最基础的订阅效果。\n接下来想，如果小明只想在双数日送奶，并且每天送两瓶奶，要如何去做。\n\n我们可以设想出以下执行逻辑。\n\n```js\ncompony$\n  .filter((i) => !(i % 2))\n  .map((i) => i * 2)\n\nconst xiaoming = (i) => console.log(`小明收到${i}瓶奶`)\n\nconst unsub = compony$.subscribe(xiaoming);\n```\n\n上面的链式写法与我们常见的`Promise.then`类似，但略有差异\n`Promise`中的`then`获取上一步结果然后执行逻辑的同时也返回了一个`Promise`,所以可以无限调用\n\n`Observable`中的这些操作符`filter`,`map`,(称作`operators`)，它接收上级`Observable1`，返回一个新的`Observable2`，`Observable2`在被订阅时，会先触发`Observable1`的订阅，并对`Observable1`发出的值进行处理。\n\n注意到,`then`接受的是上一步发出的值，`operator`接受的是整个`Observable`，这也是`Observable`在被订阅之后才发出值的原因。\n\n这特别像`Redux`中间件的洋葱圈模型，如下所示：\n\n<img src=\"https://images.tuyacn.com//smart/connect-scheme/156231608830ca2b433c5.png\" width=\"500\" height=\"auto\" />\n\n实现如下\n```js\nconst map = (action) => {\n  return (prevObservable) =>  new Observable((observer) => {\n    const sink = prevObservable.subscribe((res) => observer.next((action(res))))\n    return sink\n  })\n}\nconst filter = (action) => {\n  return (prevObservable) =>  new Observable((observer) => {\n    const sink = prevObservable.subscribe((res) => {\n      const result = action(res)\n      if (result) {\n        return  observer.next(res)\n      }\n     return null\n    })\n    return sink\n  })\n}\n```\n\n如果像上面这样子的定义的话，我们调用起来是丑陋的\n也是很难看懂的：\n```js\nmap(i => i * 2)(filter(i => i % 2)(compony$))\n```\n\n`Rxjs`官方提供了一个`pipe`的方式，让我们可以按照如下的方式调用`operator`，如下\n\n```js\ncompony$.pipe(\n  filter(i => i % 2),\n  map(i => i * 2)\n)\n\ncompony$.subscribe(xiaoming)\n```\n\n接下来我们实现这个`pipe`方法，js中有个方法叫`reduce`，能够方便的实现我们的想法，没有过的同学[戳这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)\n\n```js\nconst pipe = (source, ...fns) {\n  return fns.reduce((state, fn) => fn(state), initialValue);\n}\n```\n\n这样我们就可以以下方式调用了：\n\n```js\nconst unsub = pipe(compony$, filter(x => x % 2), operator_map(x => x + 1)).subscribe(xiaoming)\n```\n\n但是这样我们的`pipe`方法还是独立的，接下来要把`pipe`挂到`Observable`下:\n\n```js\nclass Observable {\n  constructor(subscribe) {\n    if (subscribe) {\n      this._subscribe = subscribe\n    }\n  }\n\n  subscribe(observerOrNext, error, complete) {\n    const subscription = toSubScriber(observerOrNext, error, complete)\n    const unsub = this._subscribe(subscription)\n    return unsub\n  }\n\n  pipe(...fns) {\n    return fns.reduce((state, fn) => fn(state), this);\n  }\n}\n```\n\n这样我们就实现了官方的`pipe`。\n下面贴上完整代码，实际没几行：\n```js\nconst noon = () => {}\nconst toSubScriber = (observerOrNext, error, complete) => {\n  return {\n    next: observerOrNext ? observerOrNext : noon,\n    error: error ? error : noon,\n    complete: complete ? complete : noon,\n  }\n}\n\nclass Observable {\n  constructor(subscribe) {\n    if (subscribe) {\n      this._subscribe = subscribe\n    }\n  }\n\n  subscribe(observerOrNext, error, complete) {\n    const subscription = toSubScriber(observerOrNext, error, complete)\n    const unsub = this._subscribe(subscription)\n    return unsub\n  }\n\n  pipe(...fns) {\n    return fns.reduce((state, fn) => fn(state), this);\n  }\n}\n\nconst map = (action) => {\n  return (prevObservable) =>  new Observable((observer) => {\n    const sink = prevObservable.subscribe((res) => observer.next((action(res))))\n    return sink\n  })\n}\n\nconst filter = (action) => {\n  return (prevObservable) =>  new Observable((observer) => {\n    const sink = prevObservable.subscribe((res) => {\n      const result = action(res)\n      if (result) {\n        return  observer.next(res)\n      }\n     return null\n    })\n    return sink\n  })\n}\n\n// 调用\n\nconst compony$ = new Observable((observer) => {\n  let count = 0\n  const timer = setInterval(() => {\n    console.log('鲜奶公司发货')\n    observer.next(++count);\n  }, 1000);\n  return () => {\n    console.log('取消订阅');\n    clearInterval(timer)\n  }\n});\n\nconst xiaoming = count => console.log(`小明收到${count}瓶奶`)\n\nconst unsub = compony$.pipe(\n  filter(x => x % 2),\n  operator_map(x => x + 1),\n).subscribe(observer_xiaoming)\n\nsetTimeout(() => unsub(), 40000)\n```\n\n没有依赖，各位可以自己copy看看执行结果。\n\n以上为RX实现系列1, 下节讲Rx的`单播`和`多播`以及`hot`and`cold`。\n","tags":["javascript","RxJs"]},{"title":"DNS详解","url":"/2018/08/18/DNS详解/","content":"\n#### DNS是什么\n\n我们再访问一个域名的时候，浏览器如何知道资源在哪？浏览器必须要知道某个资源的ip才能访问。DNS的作用就是翻译域名为ip地址。\n\n*DNS是一个巨大的分布式数据库*\n\nDNS是一个分布在世界各地，有层级关系的数据库。域名通过一定规则映射到到这个数据库中。\n\n首先我们来看一个域名\n\n**www.test.com.**\n\n注意到域名最后面的 *.*，这个是一个绝对域名（Fully Qualified Domain Name），简称FQDN. 上面的示例域名全写为**www.test.com.root**\n\n以实例域名来说\n- *.*， 称作 *ROOT根域名*\n- *com*， 称作 *顶级域名（TLD）*\n- *test*, 称作 *次级域名，二级域名（SLD）* \n- *www*，这一级为主机名，成为 *三级域名（host）* \n\n具体格式：**host.sld.tld.root**\n\nDNS便是根据域名的层级进行分级查询.\n\n上面说了DNS是一个分布式数据库，这个数据库的组成部分便是一个个的数据库，这些服务器用来维护DNS信息。\n\n- 最顶级是根域名服务器，对应上面域名示例中的 *.*\n  根域名服务器全球有13台，由ICANN管理。根域名服务器用来解析**TLD**服务器\n\n- TLD服务器（顶级域名服务器）\n  对应上面的 *com*，类似的 .com, .org等叫做一般通用顶级域(gTLDs), .cn, .jp这样的叫做国家顶级域 (ccTLDs)。TLD服务器负责解析Domain-Level服务器\n\n- Domain-Level 服务器,对应上面的 *test*，这个服务器一般会告诉我们某个域名解析出来的IP，比入 *www.test.com*, *smartapp.test.com*\n\n通过上面简单的描述域名的分级和DNS数据库的分级，每个层级的域名服务器只会管理他的下一级，而不会跨级管理，根域名服务器 -> TLD -> Domain-Level -> IP\n\n#### DNS的大致工作流程\n\n我们从输入一个域名到得知这个域名的IP，中间发生了什么？以smartapp.test.com为例\n\n- 1、首先浏览器会检查缓存中有没有这个域名对应的IP地址，如果有解析过程会结束。当然这个缓存时间非常短。\n- 2、如果浏览器缓存中没有，本地host文件，操作系统会先检查本地host有没有此域名的映射关系，有就完成\n- 3、如果host文件中没有，便会向本地DNS服务器（Hinet服务器）发请求进行查询，此服务器通常是由网络服务供应商（ISP）提供，比如电信，移动。也可以由我们在网络DNS设置中自己配置，常见的配置比如有谷歌的8.8.8.8，如果要查询的域名包含在本地DNS服务器资源中或者缓存了此网址的映射关系，则完成域名解析\n- 4、如果Hinet服务器解析失败，Hinet服务器就会向13台根DNS服务器发出请求，根DNS服务器收到请求后会判断这个顶级域名（.com) 由谁来授权管理，返回该顶级域名服务器的ip，Hinet服务器继续向负责此顶级域名.com的服务器发请求查询，这台顶级域名服务器收到请求后如果自己无法解析，它就会找到管理.com下一级（.test)DNS服务器（Domain-Level）服务器，并返回ip给Hinet服务器，Hinet服务器继续向此Domain-Level服务器发请求查询，通常这一步会返回域名对应的ip地址。如果没有，将继续重复上面的动作，直到找到为止。\n\n借用《鸟哥私房菜》的图：\n<img src=\"http://airtake-public-data-1254153901.cos.ap-shanghai.myqcloud.com/oceanus/image/09228b9c-f08a-5315-a83a-2339f53fab7c.png\" width=\"400\" height=\"auto\">\n\n#### 通过dig命令理解DNS工作流程\n\n通过上面的描述我们感觉域名解析到ip的过程是一个一级一级的请求过程，我们可以通过*dig*命令可以清晰的了解到这个过程。\n\n我们先简单了解常见记录类型\n\n- A，A记录既域名最终对应的ip地址\n- CNAME，CNAME记录，将域名的解析转到另一个域名记录上\n- NS，NS（Name Server)记录指定此域名由某个域名服务器进行解析\n- SOA， SOA（Start Of Authority），起始授权机构的资源记录，听起来比较绕口，SOA记录，这个是区域文件中的强制型记录，必须存在也必须是第一条记录，它记录了解释的域名，主DNS服务器，序列号（是否需要更新的标志），同步时间（从服务器向主服务器同步此区域文件的时间间隔），缓存时间等等。\n\n\n```\ndig smartapp.test.com\n```\n这条命令列出本次查询的大致信息\n\n<img src=\"https://images.tuyacn.com/smart/connect-scheme_1557738007_pptao4xf5o\" width=\"400\" height=\"auto\">\n\n客户端（比如浏览器）在查询一个域名的DNS信息的时候，是采用的递归查询的方式的方式，上面已经有详细说明。其中的本地DNS服务器为了获取到域名对应的IP，会使用迭代查询的方式（一步步询问）。通过下面这条命令我们能够比较清晰的\n```\ndig +trace smartapp.test.com\n```\n<img src=\"https://images.tuyacn.com/smart/connect-scheme_1557739101_c8w135vid4w\" width=\"600\" height=\"auto\">\n\n- 本地DNS服务器（172.31.31.31）向所有13台根DNS服务器发出询问（13台根DNS服务器地址不需要查询，已被内置在本地DNS服务器），最先响应的根域名服务器将被缓存，以后只向这台服务器发请请求。如图所示最先响应的是（192.203.230.10），（192.203.230.10）说并不知道smartapp.test.com的具体信息，你去问.com顶级域名服务器去吧，并返回.com顶级域名服务器的所有NS记录\n- 本地DNS服务器继续向所有.con顶级域名服务器发起询问，（192.52.178.30）如图是响应最快的，（192.52.178.30）顶级域名服务器说我也不知道smartapp.test.com的信息，但是我知道是.test.com是阿里云管理的，并返回阿里云服务器的所有NS记录\n- 本地服务器继续向所有阿里云DNS服务器发起请求，（203.119.159.111）是响应最快的，（203.119.159.111）说，这个域名是我管理的，并返回smartapp.test.com对应的A记录\n\n","tags":["javascript","DNS"]},{"title":"CentOS安装node8.x版本","url":"/2017/12/15/CentOS安装node8-x版本/","content":"### CentOS 安装 node 8.x 版本\n\n由于一些原因需要给CentOS服务器安装8.0以上版本的node, 本来直接通过yum管理安装管理，但是没找到好办法，在此记录一下自己最后使用的简单过程：\n\n安装之前删除原来的node和npm (我原来是用yum安装的，如果是第一次安装可以省略这一步):\n\n```\nyum remove nodejs npm -y\n```\n\n首先我们随便进入服务器的一个目录，然后从淘宝的源拉取内容:\n\n```\nwget https://npm.taobao.org/mirrors/node/v8.0.0/node-v8.0.0-linux-x64.tar.xz \n```\n\n解压缩:\n\n```\nsudo tar -xvf node-v8.0.0-linux-x64.tar.xz \n```\n\n进入解压目录下的 bin 目录，执行 ls 命令\n\n```\ncd node-v8.0.0-linux-x64/bin && ls \n```\n\n我们发现有node 和 npm\n\n这个时候我们测试:\n\n```\n./node -v\n```\n\n这个时候我们发现实际上已经安装好了，接下来就是要建立链接文件。\n\n这里还是，如果我们之前已经安装过了，那么我们要先删除之前建立的链接文件：\n\n```\nsudo rm -rf /usr/bin/node\nsudo rm -rf /usr/bin/npm\n```\n\n然后建立链接文件:\n\n```\nsudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/node /usr/bin/node\nsudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/npm /usr/bin/npm\n```\n\n注意这里的第一个路径不要直接复制粘贴，要写当前文件的真正的路径，这个可以通过pwd获取。\n\n然后我们可以通过`node -v`等测试已经安装成功。\n","tags":["centOS","Node.js"]},{"title":"CentOS7下安装和配置redis","url":"/2016/10/04/CentOS7下安装和配置redis/","content":"Redis是一个高性能的，开源key-value型数据库。是构建高性能，可扩展的Web应用的完美解决方案，可以内存存储亦可持久化存储。因为要使用跨进程，跨服务级别的数据缓存，在对比多个方案后，决定使用Redis。顺便整理下Redis的安装过程，以便查阅。\n\n\n 1 . 下载Redis\n目前，最新的Redist版本为3.0，使用wget下载，命令如下：\n```\n\n# wget http://download.redis.io/releases/redis-3.0.4.tar.gz\n\n```\n 2 . 解压Redis\n下载完成后，使用tar命令解压下载文件：\n```\n\n# tar -xzvf redis-3.0.4.tar.gz\n```\n3 . 编译安装Redis\n切换至程序目录，并执行make命令编译：\n```\n# cd redis-3.0.4\n# make\n```\n执行安装命令\n```\n# make install\n```\nmake install安装完成后，会在/usr/local/bin目录下生成下面几个可执行文件，它们的作用分别是：\n\n* redis-server：Redis服务器端启动程序\n* redis-cli：Redis客户端操作工具。也可以用telnet根据其纯文本协议来操作\n* redis-benchmark：Redis性能测试工具\n* redis-check-aof：数据修复工具\n* redis-check-dump：检查导出工具\n\n备注\n\n有的机器会出现类似以下错误：\n```\nmake[1]: Entering directory `/root/redis/src'\nYou need tcl 8.5 or newer in order to run the Redis test\n……\n```\n这是因为没有安装tcl导致，yum安装即可：\n```\nyum install tcl\n```\n4 . 配置Redis\n复制配置文件到/etc/目录：\n```\n# cp redis.conf /etc/\n```\n为了让Redis后台运行，一般还需要修改redis.conf文件：\n```\nvi /etc/redis.conf\n```\n修改daemonize配置项为yes，使Redis进程在后台运行：\n```\ndaemonize yes\n```\n5 . 启动Redis\n配置完成后，启动Redis：\n```\n# cd /usr/local/bin\n# ./redis-server /etc/redis.conf\n```\n检查启动情况：\n```\n# ps -ef | grep redis\n```\n看到类似下面的一行，表示启动成功：\n```\nroot     18443     1  0 13:05 ?        00:00:00 ./redis-server *:6379 \n```\n6 . 添加开机启动项\n让Redis开机运行可以将其添加到rc.local文件，也可将添加为系统服务service。本文使用rc.local的方式，添加service请参考：Redis 配置为 Service 系统服务 。\n\n为了能让Redis在服务器重启后自动启动，需要将启动命令写入开机启动项：\n```\necho \"/usr/local/bin/redis-server /etc/redis.conf\" >>/etc/rc.local\n```\n7 . Redis配置参数\n在 前面的操作中，我们用到了使Redis进程在后台运行的参数，下面介绍其它一些常用的Redis启动参数：\n```\ndaemonize：是否以后台daemon方式运行\npidfile：pid文件位置\nport：监听的端口号\ntimeout：请求超时时间\nloglevel：log信息级别\nlogfile：log文件位置\ndatabases：开启数据库的数量\nsave * *：保存快照的频率，第一个*表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。\nrdbcompression：是否使用压缩\ndbfilename：数据快照文件名（只是文件名）\ndir：数据快照的保存目录（仅目录）\nappendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。\nappendfsync：appendonlylog如何同步到磁盘。三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步\n```\n","tags":["centOS","redis"]},{"title":"centOS7安装nginx","url":"/2016/08/03/centOS下安装nginx/","content":"\n**1.连接自己的服务器**\n\n```\nssh root@113.25.35.52\n```\n替换成你自己的ip\n\n**2.使用yum安装Nginx**\n\n```\nyum install nginx\n```\n\n**3.启动Nginx**\n\n刚安装的Nginx不会自行启动。运行Nginx以及设置开机自启:\n```\nsystemctl start nginx.service\n```\n```\nsystemctl enable nginx.service\n```\n如果一切进展顺利的话，现在你可以通过你的域名或IP来访问你的Web页面来预览一下Nginx的默认页面\n\n**4.Nginx配置信息**\n```\n网站文件存放默认目录\n\n/usr/share/nginx/html\n网站默认站点配置\n\n/etc/nginx/conf.d/default.conf\n自定义Nginx站点配置文件存放目录,自己在这里也可以定义别的名字的.conf，这个的作用以后再说。\n\n/etc/nginx/conf.d/\nNginx全局配置\n\n/etc/nginx/nginx.conf\n在这里你可以改变设置用户运行Nginx守护程序进程一样,和工作进程的数量得到了Nginx正在运行,等等。\n```\n\n**5.Nginx基本语法**\n```\nnginx -t   \t\t\t\t\t\t#测试配置文件是否有语法错误\nnginx -s reopen\t\t\t\t\t#重启Nginx\nnginx -s reload\t\t\t\t\t #重新加载Nginx配置文件，然后以优雅的方式重启Nginx\nnginx -s stop  \t\t\t\t\t#强制停止Nginx服务\nnginx -s quit  \t\t\t\t\t\t#优雅地停止Nginx服务（即处理完所有请求后再停止服务）\nnginx -c [配置文件路径]       #为 Nginx 指定配置文件\n```","tags":["centOS","nginx"]}]