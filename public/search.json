[{"title":"我的nvim配置","url":"/2020/03/23/nvim配置/","content":"\n### 我的nvim配置\n\n一步步搭的，还是蛮好看的O(∩_∩)O\n\n```\nscriptencoding utf-8\nset encoding=utf-8\n\nlet $NVIM_TUI_ENABLE_TRUE_COLOR=1\n\" tab栏标志(airline插件)\nlet g:airline#extensions#tabline#enabled = 1\n\" 主题（airline)\nlet g:airline_theme='bubblegum'\n\" oceanic 主题\nif (has(\"termguicolors\"))\n set termguicolors\nendif\n\n\n\" 插件管理器\n\" set nocompatible\n\" filetype off\n\n\" set rtp+=~/.vim/bundle/Vundle.vim\n\n:call plug#begin('~/.local/share/nvim/plugged')\nPlug 'VundleVim/Vundle.vim'\n\n\" 主题色及代码高亮\n\" Plug 'liuchengxu/space-vim-theme'\n\" Plug 'lifepillar/vim-solarized8'\n\" Plug 'altercation/vim-colors-solarized'\nPlug 'mhartington/oceanic-next'\nPlug 'pangloss/vim-javascript'\nPlug 'mxw/vim-jsx'\nPlug 'HerringtonDarkholme/yats.vim'\n\n\" 动作栏\nPlug 'vim-airline/vim-airline'\nPlug 'vim-airline/vim-airline-themes'\n\n\" 功能插件\n\n\" 符号对齐\nPlug 'junegunn/vim-easy-align'\n\" 代码自动提示\nPlug 'neoclide/coc.nvim', {'branch': 'release'}\nPlug 'neoclide/coc-tsserver', {'branch': 'release'}\nPlug 'neoclide/coc-css', {'branch': 'release'}\nPlug 'neoclide/coc-highlight', {'branch': 'release'}\nPlug 'neoclide/coc-html', {'branch': 'release'}\n\" 输入法切换\nPlug 'https://github.com/vim-scripts/fcitx.vim.git'\n\" 文件搜索\nPlug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' } \nPlug 'junegunn/fzf.vim' \n\" 侧边栏\nPlug 'scrooloose/nerdtree'\ncall plug#end()\nfiletype plugin indent on\n\n\" 键映射\nnnoremap <silent> <C-p> :Files<CR>\nmap <C-n> :NERDTreeToggle<CR>\nmap <C-e> :Buffers<CR>\nmap <C-g> :GFiles<CR>\nlet g:fzf_action = { 'ctrl-e': 'edit' }\n\nautocmd StdinReadPre * let s:std_in=1 autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists(\"s:std_in\") | exe 'NERDTree' argv()[0] | wincmd p | ene | endif\nautocmd bufenter * if (winnr(\"$\") == 1 && exists(\"b:NERDTree\") && b:NERDTree.isTabTree()) | q | endif\n\n\" syntax enable\n\" set background=dark\n\" colorscheme solarized8\n\" colorscheme space_vim_theme\nsyntax on\nlet g:oceanic_next_terminal_bold = 1\nlet g:oceanic_next_terminal_italic = 1\ncolorscheme OceanicNext\n\n\" vim变量配置\n\n\" 当前行高亮\nset cursorline\n\" 行号配置\nset number\nset relativenumber\nset showmode\nset smartcase\n\n\" 支持tab移动选择\ninoremap <silent><expr> <TAB>\n      \\ pumvisible() ? \"\\<C-n>\" :\n      \\ <SID>check_back_space() ? \"\\<TAB>\" :\n      \\ coc#refresh()\ninoremap <expr><S-TAB> pumvisible() ? \"\\<C-p>\" : \"\\<C-h>\"\n\n\" tab缩进\nset tabstop=2\nset softtabstop=0\nset shiftwidth=2\nset expandtab\nset smarttab\n\n\" 自动缩进\nset autoindent\nset smartindent\n```\n","tags":["nvim"]},{"title":"网站全球加速","url":"/2019/12/03/网站全球加速/","content":"\n\n### 遇到的问题\n\n国内部署的网站在国外访问慢甚至不能打开\n\n### 解决方案\n\n借助腾讯提供的基于`BGP AnyCast`全球加速方案以及动态配置静态资源，实现应用在全球的可访问。\n\n先上图\n\n<img src=\"http://images.tuyacn.com/smart/connect-scheme/1580285192aa5d42d3734.png\" width=\"600\" height=\"auto\">\n\n**大致流程如下（以test.huaishuo.com为例）**\n\n- 经过阿里智能DNS解析，国外用户访问`test.huaishuo.com` `CNAME` 到一个 `CDN`域名\n- `CDN` 回源到 `test-acc.huaishuo.com`\n- `test-acc.huaishuo.com` 指向腾讯`AnyCast`加速ip\n- 经过腾讯专用通道加速到国内SLB负载均衡设备\n- SLB分流到不同的nginx\n- nginx添加国外加速访问专属头部`x-ty-acc`\n- 经过`k8s ingress`到最终的容器`pod`\n- 如果是html请求，则具体应用根据`x-ty-acc`更改静态资源前缀到国外CDN（这要求发布时静态资源要同步国外）\n- 返回具体数据\n\n### 针对流程中几个点的解释\n\n**1. 阿里智能DNS解析**\n\n`test.huaishuo.com`由阿里DNS负责解析，用户在访问域名的时候，会携带具体用户的访问ip到阿里DNS，阿里DNS作出判断分别解析成`A记录`或`CNAME`记录等。在这里我们配置的是国外访问`CNAME`到一个CDN的地址。\n\n\n**2.BGP AnyCast加速是什么**\n\n先上链接\n[https://www.cnblogs.com/zafu/p/9168617.html](https://www.cnblogs.com/zafu/p/9168617.html)\n\n`Anycast`是指`IPV6协议`中一个`发送方` 同 `最近的一组接收方` 之间的通信。其利用多个`as`号码在不同地区广播同一个`ip`段。\n\n最简单的理解就是，`不同的`的服务器用了`相同的`ip地址，然后用户访问这个ip的时候，利用`BGP`的寻路原则，选择一条最优路径，从而优化了访问速度\n\n*为何可以使用相同的ip?*\n\n传统意义上的ip是唯一的，ip地址重复会报ip地址冲突，这里利用了`as号`，它就像是一个个国家的编号，不同国家其中可以拥有相同的一个ip。\n\n举例说明：\n\n<img src=\"https://images.tuyacn.com/smart/connect-scheme/1576502058be69b7d0c3e.png\" width=\"400\" height=\"auto\">\n\n比如我们有三台服务器分别部署在北京上海和广州。传统意义上，我们想要做分流需要有一台负载均衡设备，全国的流量打到这台设备上，然后这台设备根据具体的用户及服务器状态进行分流。\n\n而现在，如果使用了`BGP AnyCast`方案，这三台服务器对互联网宣告同一ip，然后互联网路由表针对此ip就有三个不同的出口路由。当用户访问这个ip时，不再需要负载均衡设备，根据`BGP`寻路自动找到一条最优路径\n\n除了最基础的`负载均衡`，它还有例如`防DDOS攻击`等更多有点，这里不多做赘述。\n\n\n*具体到腾讯的全球加速*\n\n- 腾讯在全球多个地区部署同一ip的服务器\n- 用户访问此ip根据BGP寻最优路径访问\n- 经过腾讯专线加速到国内\n\n**3.test.huaishuo.com CNAME 到 CDN是为什么？是否多余**\n\n单纯的通过腾讯的AnyCast的加速已经能够实现全球加速的效果，直接把国外访问的`test.huaishuo.com`解析到腾讯的加速ip上已经可以实现\n\n具体原因如下：\n\n- 腾讯全球部署的节点依然不够多，而CDN的节点在全球确是非常多，加了CDN之后，加速了从`用户`到`最优IP`的这一步。\n- 我们的请求有很多种\n  - 有例如 `test.huaishuo.com` 动态的页面，以及其中的动态的接口， 这种每次都是最新的，可以利用CDN的`动态加速`，每次请求先到最近的CDN服务节点，然后再通过CDN优化过的线路，回源到源站\n  - 有例如 `smartapp.huaishuo.com/appId` 这种内容几乎不会更新的，这种我们可以利用CDN的`事件驱动`缓存，此路径实际上被CDN缓存，但当它需要被更新时，比如后台上传了新app链接，能够触发CDN更新。当然这种实际能不能配我也布吉岛\n- 省钱，加速流量贵啊\n\n**4.根据x-ty-acc头在项目中的作用**\n\n国外访问会在nginx层添加`x-ty-acc`头\n\n首先需要清楚的是我们的静态资源（js, css)有两套部署方式，一是阿里oss（之后可能会迁移到腾讯），二是AWS s3。这两种方式分别对应`static1.huaishuocn.com`, `static1.huaishuous.com`CDN前缀，后者在全球有很多节点，所以国外统一用`static1.huaishuous.com`。\n\n然后就是根据项目中是否收到`x-ty-acc`配置静态资源CDN前缀\n\n\n以上，如有错误，请联系@张照煦\n\n\n","tags":["web运维","加速"]},{"title":"RxJs实现系列1 - Observable","url":"/2019/11/18/Rx实现系列-1/","content":"\n### 本系列将一步步实现简化版的RxJS\n\n`RxJS`在我的观念里是一个有`流(streams)`式操作的观察者模型。\n我们将一步步通过简单的demo实现一个简化版的`RxJS`，没有Rx使用经验的人应该也看的懂\n\n#### 目标 - 实现如下功能\n\n```js\nconst compony$ = new Observable((observer) => {\n  let count = 0\n  const timer = setInterval(() => {\n    console.log('鲜奶公司发货')\n    observer.next(++count);\n  }, 1000);\n  return () => clearInterval(timer)\n})\n\ncompony$.pipe(\n  map(x => x + 1),\n  filter(x => x / 2 === 0)\n)\n\nconst xiaoming = (count) => console.log(`小明收到${count}瓶奶`)\n\nconst unsub = compony$.subscribe((xiaoming)\n\nsetTimeOut(() => unsub(), 30000);\n\n```\n\n先来解释下上面名词的含义, `compony$` 一个 `Observable - 可订阅（观察）对象`，负责在有顾客 `xiaoming - 订阅者（观察者)` 发出订阅动作之后，每隔一段时间发出一瓶奶，每天这个小明收到几瓶奶，也是经过一些处理的，也就是`pipe`中的一些操作`operator`。在30天取消订阅。\n\n本例引用自[Yard](http://www.yardwill.com/detail/%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84rxjs-demo%E6%9D%A5%E7%9C%8Brxjs%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81)\n\n#### 第一步\n*首先来实现一个`Observable`类，我们可以通过这个对象注册一个`可观测对象- Observable$`*\n\n```js\nclass Observable {\n  constructor(subscribe) {\n    if (subscribe) {\n      this._subscribe = subscribe\n    }\n  }\n}\n```\n\n实际使用中，注册的方式是传入一个函数。\n这个函数要具备的功能是：\n- 接受一个`observer`观察者，能给`observer`发出值\n- 返回一个取消订阅，也就是取消发出值的方法\n\n这就是那个函数：\n```js\n(observer) => {\n  let count = 0\n  const timer = setInterval(() => {\n    console.log('鲜奶公司发货')\n    observer.next(++count);\n  }, 1000);\n  return () => clearInterval(timer)\n}\n```\n\n#### 第二步\n*这个`Observable`中有一个`subscribe`方法，这个方法的作用是接受一个`observer`，进行格式化处理之后，将这个`observer`传给`Observable$`(即订阅动作)，`observer`开始接受`Observable$`发出的值*。\n\n*触发订阅动作的时候要返回注册函数提供的解绑方法，以供取消订阅使用*\n\n```js\nconst noon = () => {}\nconst toSubScriber = (observerOrNext, error, complete) => {\n  return {\n    next: observerOrNext ? observerOrNext : noon,\n    error: error ? error : noon,\n    complete: complete ? complete : noon,\n  }\n}\n\nclass Observable {\n  constructor(subscribe) {\n    if (subscribe) {\n      this._subscribe = subscribe\n    }\n  }\n\n  subscribe(observerOrNext, error, complete) {\n    const subscription = toSubScriber(observerOrNext, error, complete)\n    const unsub = this._subscribe(subscription)\n    return unsub\n  }\n}\n```\n\n到这里我们已经实现了一个很简单的观察者模型，让我们来试用下吧!\n\n```js\nconst compony$ = new Observable((observer) => {\n  let count = 0\n  const timer = setInterval(() => {\n    console.log('鲜奶公司发货')\n    observer.next(++count);\n  }, 1000);\n  return () => {\n    console.log('取消订阅');\n    clearInterval(timer)\n  }\n});\n\nconst xiaoming = (i) => console.log(`小明收到${i}瓶奶`)\n\nconst unsub = compony$.subscribe(xiaoming);\n\nsetTimeout(() => unsub(), 3000);\n```\n\n执行效果：\n\n\n### 第三步\n\n以上我们已经实现了最基础的订阅效果。\n接下来想，如果小明只想在双数日送奶，并且每天送两瓶奶，要如何去做。\n\n我们可以设想出以下执行逻辑。\n\n```js\ncompony$\n  .filter((i) => !(i % 2))\n  .map((i) => i * 2)\n\nconst xiaoming = (i) => console.log(`小明收到${i}瓶奶`)\n\nconst unsub = compony$.subscribe(xiaoming);\n```\n\n上面的链式写法与我们常见的`Promise.then`类似，但略有差异\n`Promise`中的`then`获取上一步结果然后执行逻辑的同时也返回了一个`Promise`,所以可以无限调用\n\n`Observable`中的这些操作符`filter`,`map`,(称作`operators`)，它接收上级`Observable1`，返回一个新的`Observable2`，`Observable2`在被订阅时，会先触发`Observable1`的订阅，并对`Observable1`发出的值进行处理。\n\n注意到,`then`接受的是上一步发出的值，`operator`接受的是整个`Observable`，这也是`Observable`在被订阅之后才发出值的原因。\n\n这特别像`Redux`中间件的洋葱圈模型，如下所示：\n\n<img src=\"https://images.tuyacn.com//smart/connect-scheme/156231608830ca2b433c5.png\" width=\"500\" height=\"auto\" />\n\n实现如下\n```js\nconst map = (action) => {\n  return (prevObservable) =>  new Observable((observer) => {\n    const sink = prevObservable.subscribe((res) => observer.next((action(res))))\n    return sink\n  })\n}\nconst filter = (action) => {\n  return (prevObservable) =>  new Observable((observer) => {\n    const sink = prevObservable.subscribe((res) => {\n      const result = action(res)\n      if (result) {\n        return  observer.next(res)\n      }\n     return null\n    })\n    return sink\n  })\n}\n```\n\n如果像上面这样子的定义的话，我们调用起来是丑陋的\n也是很难看懂的：\n```js\nmap(i => i * 2)(filter(i => i % 2)(compony$))\n```\n\n`Rxjs`官方提供了一个`pipe`的方式，让我们可以按照如下的方式调用`operator`，如下\n\n```js\ncompony$.pipe(\n  filter(i => i % 2),\n  map(i => i * 2)\n)\n\ncompony$.subscribe(xiaoming)\n```\n\n接下来我们实现这个`pipe`方法，js中有个方法叫`reduce`，能够方便的实现我们的想法，没有过的同学[戳这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)\n\n```js\nconst pipe = (source, ...fns) {\n  return fns.reduce((state, fn) => fn(state), initialValue);\n}\n```\n\n这样我们就可以以下方式调用了：\n\n```js\nconst unsub = pipe(compony$, filter(x => x % 2), operator_map(x => x + 1)).subscribe(xiaoming)\n```\n\n但是这样我们的`pipe`方法还是独立的，接下来要把`pipe`挂到`Observable`下:\n\n```js\nclass Observable {\n  constructor(subscribe) {\n    if (subscribe) {\n      this._subscribe = subscribe\n    }\n  }\n\n  subscribe(observerOrNext, error, complete) {\n    const subscription = toSubScriber(observerOrNext, error, complete)\n    const unsub = this._subscribe(subscription)\n    return unsub\n  }\n\n  pipe(...fns) {\n    return fns.reduce((state, fn) => fn(state), this);\n  }\n}\n```\n\n这样我们就实现了官方的`pipe`。\n下面贴上完整代码，实际没几行：\n```js\nconst noon = () => {}\nconst toSubScriber = (observerOrNext, error, complete) => {\n  return {\n    next: observerOrNext ? observerOrNext : noon,\n    error: error ? error : noon,\n    complete: complete ? complete : noon,\n  }\n}\n\nclass Observable {\n  constructor(subscribe) {\n    if (subscribe) {\n      this._subscribe = subscribe\n    }\n  }\n\n  subscribe(observerOrNext, error, complete) {\n    const subscription = toSubScriber(observerOrNext, error, complete)\n    const unsub = this._subscribe(subscription)\n    return unsub\n  }\n\n  pipe(...fns) {\n    return fns.reduce((state, fn) => fn(state), this);\n  }\n}\n\nconst map = (action) => {\n  return (prevObservable) =>  new Observable((observer) => {\n    const sink = prevObservable.subscribe((res) => observer.next((action(res))))\n    return sink\n  })\n}\n\nconst filter = (action) => {\n  return (prevObservable) =>  new Observable((observer) => {\n    const sink = prevObservable.subscribe((res) => {\n      const result = action(res)\n      if (result) {\n        return  observer.next(res)\n      }\n     return null\n    })\n    return sink\n  })\n}\n\n// 调用\n\nconst compony$ = new Observable((observer) => {\n  let count = 0\n  const timer = setInterval(() => {\n    console.log('鲜奶公司发货')\n    observer.next(++count);\n  }, 1000);\n  return () => {\n    console.log('取消订阅');\n    clearInterval(timer)\n  }\n});\n\nconst xiaoming = count => console.log(`小明收到${count}瓶奶`)\n\nconst unsub = compony$.pipe(\n  filter(x => x % 2),\n  operator_map(x => x + 1),\n).subscribe(observer_xiaoming)\n\nsetTimeout(() => unsub(), 40000)\n```\n\n没有依赖，各位可以自己copy看看执行结果。\n\n以上为RX实现系列1, 下节讲Rx的`单播`和`多播`以及`hot`and`cold`。\n","tags":["javascript","RxJs"]},{"title":"RxJs实现系列2-Subject","url":"/2019/11/06/RxJs实现系列2-Subject/","content":"\n### RxJs实现系列2-Subject\n\n根据上期实现的`Observable`来看下这种场景。一个`Observable`多个`Observer`。用代码实现如下\n\n```js\nconst compony$ = new Observable((observer) => {\n  let count = 0\n  const timer = setInterval(() => {\n    observer.next(++count);\n    if (count === 3) {\n      clearInterval(timer)\n    }\n  }, 1000);\n  return () => clearInterval(timer)\n});\n\nconst observer1 = (count) => {\n  console.log(`observer1, ${count}`)\n}\n\nconst observer2 = (count) => {\n  console.log(`observer2, ${count}`)\n}\n\ncompony$.subscribe(observer1)\n\nsetTimeout(() => compony$.subscribe(observer2), 2000)\n\n```\n\n实际得到的输出如下：\n\n```\nobserver1, 1\nobserver1, 2\nobserver2, 1\nobserver1, 3\nobserver2, 2\nobserver2, 3\n```\n\n我们会发现，当一个`observer`重新订阅后，会*生成*一个新的`Observable`，因为`Observable`实际上就是一个函数，订阅一次执行一次。\n\n我们期望的是，只有一个`Observable`，多个`observer`无论何时订阅，会接受到相同的值。这种处理方式称为组播。\n\n`RxJs`中提供了一个概念叫`Subject`.\n\n*先不说概念，直接上代码*\n\n```js\nconst noon = () => {}\nconst toSubScriber = (params = {}) => {\n  const { next = noon, error = noon, complete = noon } = params\n  return {\n    next,\n    error,\n    complete\n  }\n}\n\nclass Observable {\n  constructor(subscribe) {\n    if (subscribe) {\n      this._subscribe = subscribe.next\n    }\n  }\n  subscribe = (params) => {\n    const subscription = toSubScriber(params)\n    const unsub = this._subscribe(subscription)\n    return unsub\n  }\n  pipe = (...fns) => {\n    return fns.reduce((state, fn) => fn(state), this);\n  }\n}\n\nclass Subject {\n  constructor() {\n    this.observers = []\n  }\n  subscribe = (observer) => {\n    if (observer) {\n      this.observers.push(observer)\n    }\n  }\n  next = (value) => {\n    this.observers.forEach(o => o.next(value))\n  }\n  error = (err) => {\n    this.observers.forEach(o => o.error(err))\n  }\n  complete = (value) => {\n    this.observers.forEach(o => o.complete(value))\n  }\n}\n```\n\n从代码上看，Subject是一个有subscribe, next，error，complete的类，它的实例化对象可以被Observable直接订阅。\n看下面的用法\n\n```js\nconst compony$ = new Observable({\n  next: (observer) => {\n    let count = 0\n    const timer = setInterval(() => {\n      observer.next(++count);\n      if (count === 3) {\n        clearInterval(timer)\n      }\n    }, 1000);\n    return () => clearInterval(timer)\n  }\n});\n\nconst subject$ = new Subject()\n\nconst observer1 = {\n  next: (count) => {\n    console.log(`observer1, ${count}`)\n  }\n}\n\nconst observer2 = {\n  next: (count) => {\n    console.log(`observer2, ${count}`)\n  }\n}\n\nsubject$.subscribe(observer1)\nsetTimeout(() => subject$.subscribe(observer2), 2000)\n\ncompony$.subscribe(subject$)\n```\n\n在这个示例中，`Subject`的作用更像一个*中间人*，保存所有的`observer`，然后作为一个`observer`去订阅`company$`，接收到`company$`发出的值后，又把值广播给了所有的`observer`。\n在这其中，`Subject`这个中间人，既担任了`Observable`，又担任了`observer`。\n\n根据官方的说明，`Subject`是一个根据观察者模式实现的，可以对多个`observer`通知的类。它可以去订阅`Observable`，又可以`observer`订阅。\n\n总结：\n  - `Subject`既是`Observable`又是`Observer`\n  - `Subject`可以对保存的`observers`进行广播\n\n由于`Subject`继承了`Observable`，它可以想`Observable`一样对数据进行流式操作。当然这个简单的demo是不行的，嘿嘿\n","tags":["RxJs"]},{"title":"如何实现线上docker容器的无缝替换","url":"/2019/10/04/如何实现docker容器线上无缝替换/","content":"\n### 如何实现线上docker容器的无缝替换\n\n在自己博客线上docker容器部署中发现的问题，如果是先停用旧容器，重新构建新镜像新容器，会有一段不可访问的时间。\n\n如何能做到无缝替换呢？下面的demo思路是这样\n\n- 线上容器取名`blog_pro`, 新构建容器取名`blog_pre`，且`端口不指定自动生成`\n- 准备一份`nginx proxy模板代码`\n- 发布时先构建`blog_pre`，然后`获取blog_pre端口`，根据模板生成`新nginx配置`，`替换nginx配置`文件，`restart`之后，停用删除`blog_pro`, 重命名`blog_pre为blog_pro`\n\n下面是一份简易demo\n\n**nginx模板文件**\n```\nserver {\n  listen    80;\n  server_name *.huaishuo.top;\n\n  location / {\n    proxy_set_header  Host       $host;\n    proxy_set_header  X-Real-IP    $remote_addr;\n    proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;\n    if ($host ~ ^(www)\\.huaishuo\\.top$){\n                  proxy_pass http://127.0.0.1:${blog_port};\n    }\n    proxy_pass  http://127.0.0.1:3000;\n  }\n}\n```\n\n**node服务代码**\n```js\nconst http = require('http')\nconst downloadRepo = require('download-git-repo')\nconst { execSync } = require('child_process')\nconst fs = require('fs')\nconst path = require('path')\n\nconst resetRepo = () => {\n  if (fs.existsSync(path.join(process.cwd(), 'repo'))) {\n    execSync('rm -rf repo', { cwd: process.cwd() })\n  }\n\n  execSync('mkdir repo', { cwd: process.cwd() })\n}\n\nconst clearContainer = () => {\n  execSync('docker rm -f blog_pre || true', { stdio: 'inherit' })\n}\n\nconst buildImage = () => {\n  execSync('docker build -t=\"blog\" .', { cwd: path.join(process.cwd(), 'repo'), stdio: 'inherit' })\n  execSync('docker run --name blog_pre -d -p 3000 blog', { stdio: 'inherit' })\n}\n\nconst resetNginx = () => {\n  const containerPort = execSync('docker port blog_pre').toString('utf8').split(':')[1]\n  const conf = fs.readFileSync(`${path.join(process.cwd(), 'model', 'custom.conf')}`, 'utf8')\n\n  fs.writeFileSync('/etc/nginx/conf.d/custom.conf', conf.replace('${blog_port}', containerPort))\n  execSync('nginx -s reload', { stdio: 'inherit' })\n}\n\nconst resetContainer = () => {\n  execSync('docker rm -f blog_pro || true', { stdio: 'inherit' })\n  execSync('docker rename blog_pre blog_pro', { stdio: 'inherit' })\n}\n\nconst server = http.createServer((req, res) => {\n\n  if (req.url === '/deploy') {\n    try {\n      resetRepo()\n      // 下载你的项目代码，项目中有DockerFile\n      downloadRepo('你的项目git地址', path.join(process.cwd(), 'repo'), (err) => {\n        if (err) {\n          res.end()\n        } else {\n          // 清楚可能存在的blog_pre容器\n          clearContainer()\n          // 构建镜像\n          buildImage()\n          // 替换nginx文件\n          resetNginx();\n          // 重置镜像\n          resetContainer();\n          res.end(JSON.stringify({\n            success: true,\n            message: '发布成功',\n          }))\n        }\n      })\n    } catch (error) {\n      res.writeHead(200, {'Content-Type': 'text/plain;charset=utf-8'});\n      res.write(error)\n      res.end()\n    }\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/plain;charset=utf-8'});\n    res.write('测试测试')\n    res.end()\n  }\n})\n\nserver.listen(3333)\n\nconsole.log('server listened at localhost:3333')\n```","tags":["nginx","docker"]},{"title":"RXJS+React 实现Slider","url":"/2019/08/11/RXJS常用实例-实现Slider/","content":"\n### RXJS+React 实现Slider\n\n不多bb，上代码\n\n```js\nimport React from 'react'\nimport styles from './index.scss'\n\nimport { fromEvent } from 'rxjs/internal/observable/fromEvent'\nimport { mergeMap } from 'rxjs/internal/operators/mergeMap'\nimport { switchMap } from 'rxjs/internal/operators/switchMap'\nimport { takeUntil } from 'rxjs/internal/operators/takeUntil'\nimport { scan } from 'rxjs/internal/operators/scan'\nimport { map } from 'rxjs/internal/operators/map'\nimport { filter } from 'rxjs/internal/operators/filter'\nimport { pairwise } from 'rxjs/internal/operators/pairwise'\n\nconst setTransition = (dom) => {\n  dom.style.transition = `all 0.3s ease`\n  setTimeout(() => (dom.style.transition = ''), 300)\n}\n\nconst getPos = (e: TouchEvent) => {\n  const touch = e.touches[0] || e.changedTouches[0]\n  return [Number(touch.pageX), Number(touch.pageY)]\n}\n\nconst getX = (e: TouchEvent) => {\n  const touch = e.touches[0] || e.changedTouches[0]\n  return Number(touch.pageX)\n}\n\nconst judgeHorizontalOrVerticality = (downPos, firstMovePos) => {\n  return (\n    Math.abs(firstMovePos[0] - downPos[0]) >\n    Math.abs(firstMovePos[1] - downPos[1])\n  )\n}\n\ninterface IProps {\n  imgList: string[]\n}\n\nclass Index extends React.Component<IProps, any> {\n\n  private wrapperDom: any           // 最外层容器dom，宽度固定一屏幕\n  private imgWrapperWidth: string   // 图片容器的宽度，宽度动态计算\n  private canHorizontal: boolean    // 是否允许上下滑动\n  private translateX: number = 0    // 当前x轴位移的距离\n  private wWidth: number            // 屏幕的宽度，也为容器dom的宽度\n  private translateXWidth: number   // 可以在x轴上滑动的最大距离\n  private pageCount: number         // 图片数量\n\n  constructor(props) {\n    super(props)\n    this.state = {\n      currentIndex: 1,\n    }\n\n    this.pageCount = props.imgList.length\n    this.imgWrapperWidth = `${this.pageCount * 3.75}rem`\n  }\n\n  public componentDidMount() {\n    this.wWidth = document.body.clientWidth\n    // 记录可以滑动的最大距离，为图片容器的宽度减去一屏幕的宽度\n    this.translateXWidth = this.wrapperDom.clientWidth - this.wWidth\n    // 初始化observable并订阅\n    this.initialObservable()\n  }\n\n  // 设置图片容器translateX\n  private setTranslateX = (endTransX) => {\n    // 滑动到最右的情况\n    if (endTransX < -this.translateXWidth) {\n      endTransX = -this.translateXWidth\n    }\n    // 滑动到最左的情况\n    if (endTransX > 0) {\n      endTransX = 0\n    }\n    // 滑动\n    this.wrapperDom.style.transform = `translate(${endTransX}px, 0)`\n    // 设值\n    this.translateX = endTransX\n  }\n\n  private handleTouchmove = (pos: number[]) => {\n    const distance = pos[1] - pos[0]\n    const endTransX = this.translateX + distance\n    this.setTranslateX(endTransX)\n  }\n\n  // 判断滑动一段距离后是否加载下一页\n  private handleChangeIndex = (pos) => {\n    const { currentIndex } = this.state\n    const distance = pos.endX - pos.startX\n    // 向右， 距离五分之一屏幕，且不为最后一张\n    if (distance < 0 &&\n      distance < -(this.wWidth / 5) &&\n      currentIndex + 1 <= this.pageCount\n    ) {\n      // 需要设值动画transition, 并在执行之后清楚掉，至于为什么，试下不清\n      setTransition(this.wrapperDom)\n      this.setTranslateX(currentIndex * -this.wWidth)\n      this.setState({ currentIndex: currentIndex + 1 })\n    } else if (\n      // 向左, 距离五分之一屏幕, 且不为第一张\n      distance > 0 &&\n      distance > this.wWidth / 5 &&\n      currentIndex > 1\n    ) {\n      setTransition(this.wrapperDom)\n      this.setTranslateX((currentIndex - 2) * -this.wWidth)\n      this.setState({ currentIndex: currentIndex - 1 })\n    } else {\n      // 归位\n      setTransition(this.wrapperDom)\n      this.setTranslateX((currentIndex - 1) * -this.wWidth)\n    }\n  }\n\n  private initialObservable = () => {\n    // touch start Observable\n    const start$ = fromEvent(this.wrapperDom, 'touchstart').pipe(map((e: TouchEvent) => getPos(e)))\n    // touch move Observable\n    const move$ = fromEvent(this.wrapperDom, 'touchmove')\n    // touch end Observable\n    const end$ = fromEvent(this.wrapperDom, 'touchend').pipe(map((e: TouchEvent) => getPos(e)))\n\n    // move同时滑动\n    start$.pipe(\n      mergeMap((startPos) => {\n        return move$.pipe(\n          // 第一次move判定左右还是上下，如果是上下，则禁止左右滑动\n          // scan 会缓存上一次计算的值，并在下一次的时候传入第一个参数。首次第一个参数是undefined\n          scan((acc: [boolean, TouchEvent], currentMouseEvent: TouchEvent, index) => {\n            this.canHorizontal = acc[0]\n            if (index === 0) {\n              const currentPos = getPos(currentMouseEvent)\n              this.canHorizontal = judgeHorizontalOrVerticality(startPos, currentPos)\n            }\n            return [this.canHorizontal, currentMouseEvent]\n          }),\n          filter((arr: any) => arr[0]),\n          map((acc: [boolean, TouchEvent]) => {\n            const canMoveEvent = acc[1]\n            // 通过判定已经是左右滑动了，便禁止掉上下滑动，防止左上，左下，右上，右下放下滑动引起效果不好\n            canMoveEvent.stopPropagation()\n            canMoveEvent.preventDefault()\n            return getX(canMoveEvent)\n          }),\n          // pairwise 会缓存最近两次的值，pos1, pos2\n          pairwise(),\n          // 在滑动结束的时候清楚掉所有值\n          takeUntil(end$),\n        )\n      }),\n      // 开始订阅\n    ).subscribe((pos) => {\n      this.handleTouchmove(pos)\n    })\n\n    // 结束后时候换页\n    start$.pipe(\n      switchMap((startPos) => {\n        return end$.pipe(\n          map((endPos) => ({\n            startX: startPos[0],\n            endX: endPos[0],\n          })),\n        )\n      }),\n    ).subscribe((pos) => {\n      this.canHorizontal && this.handleChangeIndex(pos)\n      this.canHorizontal = false\n    })\n  }\n\n  public render() {\n    const { imgList } = this.props\n    const { currentIndex } = this.state\n    return (\n      // 滑动的父容器，一屏幕宽\n      <div style={{ width: '3.75rem' }}>\n        // 所有图片并排，图片容器宽度喂 3.75 * 图片张数\n        <div\n          ref={(dom) => this.wrapperDom = dom}\n          style={{ width: this.imgWrapperWidth }}\n        >\n          {imgList.map((url, index) => (<img src={url} key={index} />))}\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default Index\n\n```\n","tags":["RxJs"]},{"title":"RXJS+React实现滚动加载","url":"/2019/08/11/RXJS常用实例-滚动加载/","content":"\n## RXJS+React实现滚动加载\n\n不一定要*React*，以此为例\n以代码注释讲解\n\n```js\nimport React from 'react'\n\nimport { from } from 'rxjs/internal/observable/from'\nimport { fromEvent } from 'rxjs/internal/observable/fromEvent'\nimport { exhaustMap } from 'rxjs/internal/operators/exhaustMap'\nimport { map } from 'rxjs/internal/operators/map'\nimport { tap } from 'rxjs/internal/operators/tap'\nimport { filter } from 'rxjs/internal/operators/filter'\nimport { pairwise } from 'rxjs/internal/operators/pairwise'\n\nclass Index extends React.Component<IProps, any> {\n\n  private wrapperDom: any\n\n  public componentDidMount() {\n    // 初始化\n    const obs = this.initialScrollObservable()\n    // 开始订阅\n    obs.subscribe()\n  }\n\n  private concatProducts = async () => await fetch(...)\n\n  private initialScrollObservable = () => {\n    // 使用fromEvent创建一个Observable\n    return fromEvent(this.wrapperDom, 'scroll').pipe(\n      // 获取滚动位置\n      map((e: any) => e.target.scrollTop),\n      // 记录相邻两次的滚动位置, 抛出[pos1, pos2]\n      pairwise(),\n      // 条件过滤\n      filter((positions: number[]) => {\n        // 判断是否向下滑动\n        const isScrollDown = positions[0] < positions[1]\n        // 判断距离滚动容器底部还有200px的距离\n        const positionMeet =\n          positions[1] +\n            this.wrapperDom.clientHeight +\n            200 >=\n          this.wrapperDom.scrollHeight\n        // 同时返回这两个条件才通过筛选\n        return isScrollDown && positionMeet\n      }),\n      // exhaustMap的作用是在一次加载数据的Observable完成之后，才能再次加载\n      // from根据一个promise返回一个Observable\n      exhaustMap(() => from(this.concatProducts())),\n    )\n  }\n\n  render() {\n    return (\n      // 触发滚动事件的dom\n      <div ref={(d) => this.wrapperDom = d}>\n        ....\n      </div>\n    )\n  }\n}\n\nexport default Index\n\n\n```","tags":["RxJs"]},{"title":"RXJS 时间验证码功能","url":"/2019/08/11/RXJS常用实例-验证码/","content":"\n### RXJS 时间验证码功能\n\n不多bb，上代码，这次采用`subject`的写法\n\n```js\nimport { Subject, from, timer } from 'rxjs'\nimport { take, filter, exhaustMap, mergeMap } from 'rxjs/operators'\n\nconst send$ = new Subject()\n\nconst send = async () => {\n  await fetch(...)\n}\n\nsend$.pipe(\n  // 一次请求结束前下次没用，防连点\n  exhaustMap((phoneNumber) => from(send())),\n  // 筛选正确的请求\n  filter((res: any) => res.success),\n  // 请求成功之后开始倒计时\n  mergeMap(() => timer(0, 1000)),\n  // 取60次\n  take(60),\n)\n\n// 开始订阅\nthis.count$.subscribe((n: number) => {\n  // do something\n  // 因为是用take，只会执行60次，所以需要在结束后重新订阅\n}, () => {}, this.subscribeSubject)\n\n// 发出值\nsend$.next()\n```","tags":["RxJs"]},{"title":"babel7搭建简单的node脚本开发工具","url":"/2019/07/22/babel7搭建简单的node脚本开发环境/","content":"\n## babel7搭建简单的node脚本开发工具\n\n不多bb，上代码\n\n*.babelrc文件*\n\n```js\n{\n  \"presets\": [\n    [\n      \"@babel/preset-env\",\n      {\n        \"targets\": {\n          \"node\": \"current\"\n        }\n      }\n    ]\n  ]\n}\n```\n\n*package.json*\n```js\n{\n  \"name\": \"test\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"dev\": \"babel-watch -w src src/index.js\",\n    \"build\": \"rm -rf ./lib && babel ./src/*.js --out-dir lib\"\n  },\n  \"author\": \"huaishuo\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@babel/cli\": \"^7.8.4\",\n    \"@babel/core\": \"^7.8.4\",\n    \"@babel/node\": \"^7.8.4\",\n    \"@babel/plugin-transform-runtime\": \"^7.8.3\",\n    \"@babel/preset-env\": \"^7.8.4\",\n    \"@babel/runtime\": \"^7.8.4\",\n    \"babel-watch\": \"^7.0.0\"\n  }\n}\n\n```\n\n然后在*src/index.js*下开发，可以用`es7`特性，打包后的文件在`lib`下\n","tags":["babel"]},{"title":"js生成html并下载","url":"/2019/06/15/js生成html并下载/","content":"\n\n### js生成html并下载\n\n**方案**\n- 服务端采用`react`渲染模板，返回`string`\n- 前端通过`blob`创建文件，通过`objectUrl`形式触发下载\n\n不多bb，直接上代码\n\n*server端, 采用koa*\n```js\nimport { renderToNodeStream, renderToString } from 'react-dom/server'\n\nasync getHtml(ctx) {\n  const html = renderToString(React.createElement(...))\n  ctx.body = html\n}\n\n```\n\n*前端*\n```js\nfetch({\n  ...\n}).then((res) => res.blob().then((blob) => {\n  const aLink = document.createElement('a')\n  const url = window.URL.createObjectURL(blob)\n  aLink.href = url\n  aLink.download = 'test.html'\n  aLink.click()\n  window.URL.revokeObjectURL(url)\n}))\n```","tags":["js"]},{"title":"docker常用命令记录","url":"/2019/05/12/docker常用命令记录/","content":"\n## docker常用命令记录\n\n- 已存在镜像的情况下，启动一个容器，指定映射端口，指定挂载目录\n```js\ndocker run --name `containerName` -d -p 8888:3000 -v `原始绝对路径`:`容器绝对路径` `imageName`\n```\n\n- 已存在镜像情况下，启动一个容器，将容器的某个端口映射到主机的任意端口\n- 查看这个容器的映射端口\n```js\ndocker run --name `containerName` -d -p 3000 `imageName`\ndocker port `containerId`\n```\n\n- 与容器的运行环境交互\n```js\ndocker exec -it `containerId` sh\n```\n\n- 从一个`Dockerfile`构建镜像\n```js\ndocker build -t=\"test\" `Dockerfile路径`\n```\n\n","tags":["docker"]},{"title":"H5唤醒app方式汇总","url":"/2019/04/03/H5唤醒app方式汇总/","content":"\n\n### H5唤醒App方式汇总\n\n最近在做扫码之后的h5页面唤醒App的功能，做下记录\n\n**1.唤醒方式列表**\n- URL Schemes\n- chrome intent\n- ios UniversalLink / android appLink\n\n**2.常见唤醒媒介**\n- iframe\n- a标签\n- window.location\n- URL Scheme\n\n**3.组成**\n```\n[scheme:][//authority][path][?query] 比如：tuyasmart://home?test=1\n```\n\n**4.是什么**\n\n*URL Schemes*可以理解为一种特殊的URL用来定位一个应用以及应用内的某个功能，类比网页链接便很容易理解\n*Schemes* 表示的是URL中的一个位置 - 最初始的位置，既`://`之前的字符，比如`https://www.apple.com`的*Schemes*就是`https`\n通过*URL Schemes*, 我们就可以像定位一个网页一样，定位一个应用甚至应用内的某个具体的功能。而定位是哪个应用的，就是*Schemes*部分。比如短信应用的Schemes就是： sms\n我们完全可以按照理解一个网页的URL来理解一个应用的URL\n|| 网页（苹果）| 应用（微信）| \n| 网站首页/打开应用 | https://www.apple.com | weixin:// |\n| 子页面/具体功能  | .../mac (Mac应用页) | weixin://dl/moments（朋友圈） |\n注意点 - 应用是否支持*URL Schemes*要看App开发者有没有写那部分的代码了 - *URL Schemes* 不唯一\n\n**5.使用**\n使用方式十分简单，就像我们打开一个链接一样，常见的有\n- location.href\n- iframe\n- a标签\n\n**6.使用中常见问题及解决方案**\n\n- 可能会被app禁掉，比如微信，qq等\n- ios9+ 禁止掉了iframe方式。\n- ios及部分安卓浏览器会提示用户是否打开App，并且ios在未安装对应App的时候，会提示“打不开网页，因为该网址无效”\nh5无法感知是否唤醒成功\n- 大部分浏览器需要用户手动触发链接，js自动触发无效\n\n针对被app禁止掉的情况，通常会判断是否微信等app环境，然后提示用户浏览器内打开 针对*ios9+ iframe* 被禁掉的情况，判断下ios版本 针对h5无法感知是否唤醒成功的解决办法是，`一段时间之后自动跳转下载页，或者是依赖setTimeout在浏览器进入后台后进程切换导致的时间延迟判断`。\n\n**7.Intent**\n\n安卓的原生谷歌浏览器从*chrome25*版本之后就不能通过*URL Schemes*唤醒安卓应用。要使用谷歌官方提供的*intent:*预发， 如果唤醒失败，则会跳转到谷歌的应用市场。语法与*URL Schemes*及其相似，相当于谷歌定制版的URL Schemes，也没用过，就不多说。\n\n\n**8.IOS Universal Link**\n简介 *Universal Link*是在iOS9引入的新功能，通过传统的HTTP链接就可以唤醒app，如果用户没有安装APP，则会跳转到该链接对应的页面，而且在唤醒app的时候没有弹框提示哦。可以说是解决了URL Schemes的大部分问题。\n\n*原理及流程*\n- App开发人员去配置中心配置Associated Domain配置一个支持https的域名，比如app-support.test.com\n- 然后 app-support.test.com/apple-app-site-association或者app-support.test.com/apple-app-site-association/.well-known/apple-app-site-association要返回app的teamId,bundleId,paths信息\n\n```js\nrouter.get('/apple-app-site-association, (req, res) => {\n  const data = {\n    applinks: {\n      apps: [],\n      details: [\n        {\n          appID: 'teamId.bundleId',\n          paths: ['*']\n        }\n      ]\n    }\n  };\n  res.set('Content-Type', 'text/html');\n  res.send(JSON.stringify(data));\n});\n```\n - 然后APP安装后首次打开，如果Associated Domain配置了的话，就会去请求app-support.test.com/apple-app-site-association。系统会根据返回的teamId,bundleId,paths知道当打开app-support.test.com下的哪些路径的时候唤醒对应的app，比如paths=*的话，就是打开app-support.test.com下的任意路径都会唤醒app\n \n - app那边会收到对应的路径，然后要根据path写逻辑跳转到对应的功能\n \n如何验证配置成功 - 在备忘录中输入配置好的链接，直接点开这个链接(https://app-support.test.com)，配置好的话会直接跳到app， 或者长按，弹出菜单中会提示在xxx中打开 - 在safari中\n\n*常见问题*\n\n- 微信等几个App还是给屏蔽了\n- 从9.3.X改版之后，通用链接不支持域内跳转了，跳转前后的两个domain必须是不同的，否则只会safari打开。比如知乎的网站地址是https://www.zhihu.com，而universal link的地址是oia.zhihu.com\n- 服务器上apple-app-site-association的更新不会让iOS本地的apple-app-site-association同步更新，即iOS只会在App第一次启动时请求一次，以后除非App更新或重新安装，否则不会在每次打开时请求apple-app-site-association。\n\n\n**9.Android App Links**\n安卓*App Link**的出现原因也是为了优化用户体验，在使用scheme唤醒时会弹出一个对话框提示用户是否打开，并且如果用户勾选了取消之后，可能之后就再也唤醒不了。\n安卓App Link的流程和*ios Universal link*的类似，iOS中需要配置的`app-support.test.com/apple-app-site-association`文件在安卓中叫做`app-support.test.com/.well-known/assetlinks.json`，只能放在.well-known下面","tags":["javascript","H5与app交互"]},{"title":"DNS详解","url":"/2018/08/18/DNS详解/","content":"\n#### DNS是什么\n\n我们再访问一个域名的时候，浏览器如何知道资源在哪？浏览器必须要知道某个资源的ip才能访问。DNS的作用就是翻译域名为ip地址。\n\n*DNS是一个巨大的分布式数据库*\n\nDNS是一个分布在世界各地，有层级关系的数据库。域名通过一定规则映射到到这个数据库中。\n\n首先我们来看一个域名\n\n**www.test.com.**\n\n注意到域名最后面的 *.*，这个是一个绝对域名（Fully Qualified Domain Name），简称FQDN. 上面的示例域名全写为**www.test.com.root**\n\n以实例域名来说\n- *.*， 称作 *ROOT根域名*\n- *com*， 称作 *顶级域名（TLD）*\n- *test*, 称作 *次级域名，二级域名（SLD）* \n- *www*，这一级为主机名，成为 *三级域名（host）* \n\n具体格式：**host.sld.tld.root**\n\nDNS便是根据域名的层级进行分级查询.\n\n上面说了DNS是一个分布式数据库，这个数据库的组成部分便是一个个的数据库，这些服务器用来维护DNS信息。\n\n- 最顶级是根域名服务器，对应上面域名示例中的 *.*\n  根域名服务器全球有13台，由ICANN管理。根域名服务器用来解析**TLD**服务器\n\n- TLD服务器（顶级域名服务器）\n  对应上面的 *com*，类似的 .com, .org等叫做一般通用顶级域(gTLDs), .cn, .jp这样的叫做国家顶级域 (ccTLDs)。TLD服务器负责解析Domain-Level服务器\n\n- Domain-Level 服务器,对应上面的 *test*，这个服务器一般会告诉我们某个域名解析出来的IP，比入 *www.test.com*, *smartapp.test.com*\n\n通过上面简单的描述域名的分级和DNS数据库的分级，每个层级的域名服务器只会管理他的下一级，而不会跨级管理，根域名服务器 -> TLD -> Domain-Level -> IP\n\n#### DNS的大致工作流程\n\n我们从输入一个域名到得知这个域名的IP，中间发生了什么？以smartapp.test.com为例\n\n- 1、首先浏览器会检查缓存中有没有这个域名对应的IP地址，如果有解析过程会结束。当然这个缓存时间非常短。\n- 2、如果浏览器缓存中没有，本地host文件，操作系统会先检查本地host有没有此域名的映射关系，有就完成\n- 3、如果host文件中没有，便会向本地DNS服务器（Hinet服务器）发请求进行查询，此服务器通常是由网络服务供应商（ISP）提供，比如电信，移动。也可以由我们在网络DNS设置中自己配置，常见的配置比如有谷歌的8.8.8.8，如果要查询的域名包含在本地DNS服务器资源中或者缓存了此网址的映射关系，则完成域名解析\n- 4、如果Hinet服务器解析失败，Hinet服务器就会向13台根DNS服务器发出请求，根DNS服务器收到请求后会判断这个顶级域名（.com) 由谁来授权管理，返回该顶级域名服务器的ip，Hinet服务器继续向负责此顶级域名.com的服务器发请求查询，这台顶级域名服务器收到请求后如果自己无法解析，它就会找到管理.com下一级（.test)DNS服务器（Domain-Level）服务器，并返回ip给Hinet服务器，Hinet服务器继续向此Domain-Level服务器发请求查询，通常这一步会返回域名对应的ip地址。如果没有，将继续重复上面的动作，直到找到为止。\n\n借用《鸟哥私房菜》的图：\n<img src=\"http://airtake-public-data-1254153901.cos.ap-shanghai.myqcloud.com/oceanus/image/09228b9c-f08a-5315-a83a-2339f53fab7c.png\" width=\"400\" height=\"auto\">\n\n#### 通过dig命令理解DNS工作流程\n\n通过上面的描述我们感觉域名解析到ip的过程是一个一级一级的请求过程，我们可以通过*dig*命令可以清晰的了解到这个过程。\n\n我们先简单了解常见记录类型\n\n- A，A记录既域名最终对应的ip地址\n- CNAME，CNAME记录，将域名的解析转到另一个域名记录上\n- NS，NS（Name Server)记录指定此域名由某个域名服务器进行解析\n- SOA， SOA（Start Of Authority），起始授权机构的资源记录，听起来比较绕口，SOA记录，这个是区域文件中的强制型记录，必须存在也必须是第一条记录，它记录了解释的域名，主DNS服务器，序列号（是否需要更新的标志），同步时间（从服务器向主服务器同步此区域文件的时间间隔），缓存时间等等。\n\n\n```\ndig smartapp.test.com\n```\n这条命令列出本次查询的大致信息\n\n<img src=\"https://images.tuyacn.com/smart/connect-scheme_1557738007_pptao4xf5o\" width=\"400\" height=\"auto\">\n\n客户端（比如浏览器）在查询一个域名的DNS信息的时候，是采用的递归查询的方式的方式，上面已经有详细说明。其中的本地DNS服务器为了获取到域名对应的IP，会使用迭代查询的方式（一步步询问）。通过下面这条命令我们能够比较清晰的\n```\ndig +trace smartapp.test.com\n```\n<img src=\"https://images.tuyacn.com/smart/connect-scheme_1557739101_c8w135vid4w\" width=\"600\" height=\"auto\">\n\n- 本地DNS服务器（172.31.31.31）向所有13台根DNS服务器发出询问（13台根DNS服务器地址不需要查询，已被内置在本地DNS服务器），最先响应的根域名服务器将被缓存，以后只向这台服务器发请请求。如图所示最先响应的是（192.203.230.10），（192.203.230.10）说并不知道smartapp.test.com的具体信息，你去问.com顶级域名服务器去吧，并返回.com顶级域名服务器的所有NS记录\n- 本地DNS服务器继续向所有.con顶级域名服务器发起询问，（192.52.178.30）如图是响应最快的，（192.52.178.30）顶级域名服务器说我也不知道smartapp.test.com的信息，但是我知道是.test.com是阿里云管理的，并返回阿里云服务器的所有NS记录\n- 本地服务器继续向所有阿里云DNS服务器发起请求，（203.119.159.111）是响应最快的，（203.119.159.111）说，这个域名是我管理的，并返回smartapp.test.com对应的A记录\n\n","tags":["javascript","DNS"]},{"title":"git常用小技巧","url":"/2018/03/04/git常用小技巧/","content":"\n### git常用小技巧\n\n*撤销commit*\n\n```js\ngit reset --soft HEAD^\n```\n\n*撤销add*\n\n```js\ngit reset --mixed\n```\n\n*删除中间某几个commit*\n```js\nA - B - C - D - E  // 字母代表commitId，比如我想撤销，B和D\n// 首先\ngit rebase -i A\n\n// 然后出现编辑文件\n// 删除调\npick B ...\npick D ...\n// 保存\n```\n\n*让你的git log好看点*\n\n```js\ngit config --global alias.glog \"log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'\"\n```","tags":["git"]},{"title":"CentOS安装node8.x版本","url":"/2017/12/15/CentOS安装node8-x版本/","content":"### CentOS 安装 node 8.x 版本\n\n由于一些原因需要给CentOS服务器安装8.0以上版本的node, 本来直接通过yum管理安装管理，但是没找到好办法，在此记录一下自己最后使用的简单过程：\n\n安装之前删除原来的node和npm (我原来是用yum安装的，如果是第一次安装可以省略这一步):\n\n```\nyum remove nodejs npm -y\n```\n\n首先我们随便进入服务器的一个目录，然后从淘宝的源拉取内容:\n\n```\nwget https://npm.taobao.org/mirrors/node/v8.0.0/node-v8.0.0-linux-x64.tar.xz \n```\n\n解压缩:\n\n```\nsudo tar -xvf node-v8.0.0-linux-x64.tar.xz \n```\n\n进入解压目录下的 bin 目录，执行 ls 命令\n\n```\ncd node-v8.0.0-linux-x64/bin && ls \n```\n\n我们发现有node 和 npm\n\n这个时候我们测试:\n\n```\n./node -v\n```\n\n这个时候我们发现实际上已经安装好了，接下来就是要建立链接文件。\n\n这里还是，如果我们之前已经安装过了，那么我们要先删除之前建立的链接文件：\n\n```\nsudo rm -rf /usr/bin/node\nsudo rm -rf /usr/bin/npm\n```\n\n然后建立链接文件:\n\n```\nsudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/node /usr/bin/node\nsudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/npm /usr/bin/npm\n```\n\n注意这里的第一个路径不要直接复制粘贴，要写当前文件的真正的路径，这个可以通过pwd获取。\n\n然后我们可以通过`node -v`等测试已经安装成功。\n","tags":["centOS","Node.js"]},{"title":"babel7搭建简单的node脚本开发工具","url":"/2017/11/07/js调用复制碰到的坑/","content":"\n## JS调用复制碰到的坑\n\n*先上正确代码*\n```js\n  const input = document.createElement('input')\n  document.body.appendChild(input)\n  input.setAttribute('value', codes[selectedCode])\n  input.select()\n  \n  if (document.execCommand('copy')) {\n    document.execCommand('copy')\n  }\n\n  document.body.removeChild(input)\n```\n\n*遇到的第一个问题*\n\ninput标签如果设置style的width和height为0会失效，所以请设置opacity=0。\n\n*第二个问题*\n\ninput标签必须塞一次删一次，如果一直用一个input标签，通过`setAttribute('value', 'xxx')`的方式的话，只有第一次会生效，也不明白为什么。\n","tags":["日常"]},{"title":"centOS7安装nginx","url":"/2016/08/03/centOS下安装nginx/","content":"\n**1.连接自己的服务器**\n\n```\nssh root@113.25.35.52\n```\n替换成你自己的ip\n\n**2.使用yum安装Nginx**\n\n```\nyum install nginx\n```\n\n**3.启动Nginx**\n\n刚安装的Nginx不会自行启动。运行Nginx以及设置开机自启:\n```\nsystemctl start nginx.service\n```\n```\nsystemctl enable nginx.service\n```\n如果一切进展顺利的话，现在你可以通过你的域名或IP来访问你的Web页面来预览一下Nginx的默认页面\n\n**4.Nginx配置信息**\n```\n网站文件存放默认目录\n\n/usr/share/nginx/html\n网站默认站点配置\n\n/etc/nginx/conf.d/default.conf\n自定义Nginx站点配置文件存放目录,自己在这里也可以定义别的名字的.conf，这个的作用以后再说。\n\n/etc/nginx/conf.d/\nNginx全局配置\n\n/etc/nginx/nginx.conf\n在这里你可以改变设置用户运行Nginx守护程序进程一样,和工作进程的数量得到了Nginx正在运行,等等。\n```\n\n**5.Nginx基本语法**\n```\nnginx -t   \t\t\t\t\t\t#测试配置文件是否有语法错误\nnginx -s reopen\t\t\t\t\t#重启Nginx\nnginx -s reload\t\t\t\t\t #重新加载Nginx配置文件，然后以优雅的方式重启Nginx\nnginx -s stop  \t\t\t\t\t#强制停止Nginx服务\nnginx -s quit  \t\t\t\t\t\t#优雅地停止Nginx服务（即处理完所有请求后再停止服务）\nnginx -c [配置文件路径]       #为 Nginx 指定配置文件\n```","tags":["centOS","nginx"]}]